<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Go Context 源码阅读 | Junebao</title>

  
  <meta name="author" content="Junebao">
  

  
  <meta name="description" content="Go Context 源码在 Go 服务中，往往由一个独立的 goroutine 去处理一次请求，但在这个 goroutine 中，可能会开启别的 goroutine 去执行一些具体的事务，如数据库，RPC 等，同时，这一组 goroutine 可能还需要共同访问一些特殊的值，如用户 token, ">
  

  
  
  <meta name="keywords" content="go">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Go Context 源码阅读"/>

  <meta property="og:site_name" content="Junebao"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Junebao" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Junebao</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        
          <li><a class="menu-uncover-a" href="/">主页</li>
        
      
        
          <li><a class="menu-uncover-a" href="/archives">归档</li>
        
      
        
          <li><a class="menu-uncover-a" href="/tags">标签</li>
        
      
        
          <li><a class="menu-uncover-a" href="/about">关于</li>
        
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Go Context 源码阅读</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/03/09/04_并发控制/" rel="bookmark">
        <time class="entry-date published" datetime="2022-03-09T04:55:15.000Z">
          2022-03-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Go-Context-源码"><a href="#Go-Context-源码" class="headerlink" title="Go Context 源码"></a>Go Context 源码</h1><p>在 Go 服务中，往往由一个独立的 goroutine 去处理一次请求，但在这个 goroutine 中，可能会开启别的 goroutine 去执行一些具体的事务，如数据库，RPC 等，同时，这一组 goroutine 可能还需要共同访问一些特殊的值，如用户 token, 请求过期时间等，当一个请求超时后，我们希望与此请求有关的所有 goroutine 都能快速退出，以回收系统资源。</p>
<p>context 包由谷歌开源，在 Go 1.7 时加入标准库，使用它可以很容易的把特定的值，取消信号， 截止日期传递给请求所涉及的所有 goroutine。</p>
<p>context 包的核心是 <code>Context</code> 接口，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Done</code> 返回一个 <code>chan</code>, 表示一个取消信号，当这个通道被关闭时，函数应该立刻结束工作并返回。</li>
<li><code>Err()</code> 返回一个 <code>error</code>, 表示取消上下文的原因</li>
<li><code>Deadline</code> 会返回上下文取消的时间</li>
<li><code>Value</code> 用于从上下文中获取 <code>key</code> 对应的值</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="传递取消信号（cancelation-signals）"><a href="#传递取消信号（cancelation-signals）" class="headerlink" title="传递取消信号（cancelation signals）"></a>传递取消信号（cancelation signals）</h4><p>正如使用 <code>chan</code> 控制并发一样，我们希望传递给 goroutine 一个信号，一旦接收到这个信号，就立刻停止工作并返回，context 包提供了一个 <code>WithCancel()</code>, 使用它可以很方便的传递取消信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useContext</span><span class="params">(ctx context.Context, id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;stop&quot;</span>, id)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            run(id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    nCtx, nStop := context.WithCancel(ctx)</span><br><span class="line">    <span class="keyword">go</span> G4(nCtx)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;stop 2&quot;</span>)</span><br><span class="line">            nStop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            run(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G3</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">   useContext(ctx, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G4</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    useContext(ctx, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, done := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> G2(ctx)</span><br><span class="line">    <span class="keyword">go</span> G3(ctx)</span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">    done()</span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置截止时间"><a href="#设置截止时间" class="headerlink" title="设置截止时间"></a>设置截止时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G6</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            t, _ := ctx.Deadline()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[*] %v done: %v\n&quot;</span>, t, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;[#] run ...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ctx, done := context.WithTimeout(context.Background(), time.Second * 2)</span></span><br><span class="line">    ctx, _ := context.WithTimeout(context.Background(), time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> G6(ctx)</span><br><span class="line">    <span class="comment">//done()</span></span><br><span class="line">    time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[#] run ...</span><br><span class="line">...</span><br><span class="line">[*] <span class="number">2020</span><span class="number">-10</span><span class="number">-31</span> <span class="number">20</span>:<span class="number">24</span>:<span class="number">42.0581352</span> +<span class="number">0800</span> CST m=+<span class="number">2.008975001</span> done: context deadline exceeded</span><br></pre></td></tr></table></figure>

<h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G7</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;cancel&quot;</span>, ctx.Value(<span class="string">&quot;key&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;running &quot;</span>, ctx.Value(<span class="string">&quot;key&quot;</span>))</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, _ := context.WithTimeout(context.Background(), time.Second * <span class="number">2</span>)</span><br><span class="line">    ctx =  context2.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> G7(ctx)</span><br><span class="line">    time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="context-包概览"><a href="#context-包概览" class="headerlink" title="context 包概览"></a>context 包概览</h3><p>context 包的核心是 <code>context.Context</code> 接口，另外有四个 <code>struct</code> 实现了 <code>Context</code> 接口，分别是 <code>emptyCtx</code>, <code>cancelCtx</code>, <code>timerCtx</code>, <code>valueCtx</code>, 其中 <code>emptyCtx</code> 是一个默认的空结构体，其余三个都是在其基础上添加了各自功能的实现，针对 <code>emptyCtx</code> ，context 包中暴露了两个方法 <code>Background()</code> 和 <code>TODO()</code> 去创建一个空的 <code>emptyCtx</code>, 而针对后面三种具体的 <code>struct</code> ，context 包总共暴露了四个方法去产生对应的 <code>struct</code>, 他们分别是： <code>WithCancel()</code>, <code>WithDeadLine()</code>, <code>WithTimeout()</code>, <code>WithValue()</code>,对应关系如下：</p>
<img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1604135898765-1604135898436.png" style="zoom:80%;" />

<h3 id="TODO-和-Background"><a href="#TODO-和-Background" class="headerlink" title="TODO 和 Background"></a>TODO 和 Background</h3><p>TODO 和 Background 方法用来返回一个 <code>emptyCtx</code> 类型，他们在实现上都一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">	todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法都会返回一个非空的上下文 <code>emptyCtx</code>，他永远不会被取消，用于传递给其他方法去构建更加复杂的上下文对象，一般默认使用 <code>Background()</code>, 只有在不确定时使用<code>TODO()</code>, 但实际上他们只是名字不同而已。</p>
<p>下面是 <code>emptyCtx</code> 的实现，他确实没做任何事。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// 用于同步</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// 会在 Done 中返回</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 子上下文列表，done 被关闭后，会遍历这个 map，关闭所有的子上下文</span></span><br><span class="line">	err      <span class="type">error</span>                 <span class="comment">// 关闭 chan 产生的异常，在初始化时会被赋值使不为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>WithCancel</code> 时， 首先会根据 <code>parent</code> 拷贝一个新的 <code>cancelCtx</code>: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">	<span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会调用 <code>propagateCancel</code> 安排子上下文在父上下文结束时结束，最后除了 <code>cancelCtx</code> 的引用外还会返回一个 <code>func</code>, 该方法里调用了 <code>c.cancel()</code>, 也就是当我们调用 <code>done()</code> 时，调用的其实是 <code>c.cancel()</code></p>
<h4 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h4><p><code>cancel</code> 的作用是关闭 当前上下文以及子上下文的<code>cancelCtx.done</code> 管道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 必须要有关闭的原因</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span>     <span class="comment">// 已经关闭，返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err    <span class="comment">// 通过 err 标识已经关闭</span></span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)   <span class="comment">// 关闭当前 done</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 由于是 map, 所以关闭顺序是随机的</span></span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)   <span class="comment">// 遍历取消所有子上下文</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span>    <span class="comment">// 删除子上下文</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)   <span class="comment">// 从父上下文删除自己</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="propagateCancel"><a href="#propagateCancel" class="headerlink" title="propagateCancel"></a>propagateCancel</h4><p>该函数的作用是保证父上下文结束时子上下文也结束，一方面，在生成子上下文的过程中，如果父亲已经被取消，那 <code>child</code> 也会被关闭，另一方面，如果在执行过程中父上下文一直开启，那就正常把子上下文加入到父上下文的 <code>children</code> 列表中等执行 <code>cancel</code>再关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="comment">// 如果父亲的 Done 方法返回空，说明父上下文永远不会被取消</span></span><br><span class="line">    <span class="comment">// 这种情况对应 ctx, done := context.WithCancel(context.Background())</span></span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果到这父上下文已经被取消了，就关闭当前上下文</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父亲没有被取消</span></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="comment">// 父亲已经取消，关闭自己</span></span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把 child 加到 parent 的 children 中</span></span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父上下文是开发者自定义的类型， 开启一个 goroutine 监听父子上下文直到其中一个关闭</span></span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WithTimeout-和-WithDeadline"><a href="#WithTimeout-和-WithDeadline" class="headerlink" title="WithTimeout 和 WithDeadline"></a>WithTimeout 和 WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer</span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timerCtx</code>是在 <code>cancelCtx</code>的基础上添加了一个定时器和截止时间实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的截止时间比父上下文的截止时间晚，也就是说父上下文一定会比子上下文先结束</span></span><br><span class="line">    <span class="comment">// 这种情况下给子上下文设置截止时间是没有任何意义的，所以会直接创建一个 cancelCtx</span></span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 构建新的 timerCtx</span></span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 保证子上下文在父上下文关闭时关闭</span></span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">    <span class="comment">// 计算当前距离截止时间 d 还有多长时间</span></span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">    <span class="comment">// 如果已经过了截止时间，关闭子上下文</span></span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="comment">// c.err == nil 说明当前上下文还没有被关闭</span></span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// AfterFunc 等待 dur 后会开启一个 goroutine 执行 传入的方法，即 c.cancel</span></span><br><span class="line">        <span class="comment">// 并会返回一个计时器 timer，通过调用 timer 的 Stop 方法可以停止计时取消调用。</span></span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timerCtx</code> 的 <code>cancel</code> 方法主要还是调用了 <code>cancelCtx.cancel</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 cancelCtx.cancel，关闭子上下文</span></span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    <span class="comment">// 从父上下文中删除当前上下文</span></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 停止计时，取消调用</span></span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WithTimeout</code> 直接调用了 <code>WithDeadline</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">    <span class="comment">// key 不能为 nil</span></span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// key 必须是可比较的</span></span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. </p>
<p>key 请尽量使用自定义的 struct{}, 避免使用内置数据类型以避免使用 context 包时的冲突</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>context 包是 Go 1.7 后加入的一种用于复杂场景下并发控制的模型，最核心的接口是 <code>context.Context</code>, 这个结构体中定义了五个待实现的方法，用来实现发送关闭信号，设置 dateline，传递值等功能。</p>
<p>context 包的核心思想是以 <strong>树形</strong> 组织 goroutine, 创建新上下文时需要给他指定一个父上下文，由此，根上下文对应根 goroutine, 子上下文对应子 Goroutine, 实现灵活的并发控制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1604222412407-1604222412159.png"></p>
<p>rootContext 一般通过 <code>Background()</code> 或 <code>TODO()</code> 创建，他们会创建一个空的 <code>emptyCtx</code>, 然后如果想要使用 context 包的具体功能，可以使用 <code>WithCancel()</code>， <code>WithDateline()</code> 或 <code>WithValue()</code> 将父上下文包装成具体的上下文对象（<code>cancelCtx, timerCtx, valueCtx</code>），前两个方法会返回两个值 <code>(ctx Context, done func())</code> 调用 <code>done</code> 可以向 goroutine 发送一个关闭信号， goroutine 中监控 <code>ctx.Done()</code> 便可得到这个信号。</p>
<p><code>cancelCtx</code> 和 <code>timerCtx</code> 会保持一个 <code>children</code>（<code>timerCtx</code> 实际上是继承了 <code>cancelCtx</code>），这是一个 <code>map</code> key 是 <code>canceler</code> , Value 是 <code>struct&#123;&#125;</code> 类型，值并没什么用，在创建 <code>cancelCtx</code> 或 <code>timerCtx</code>时，会把当前上下文加入到其父亲的 <code>children</code> 中，在父上下文关闭时会遍历 <code>children</code> 关闭所有的子上下文，并将本上下文从其父上下文的 <code>children</code> 中删除，由于 <code>map</code> 遍历的无序性，子上下文关闭的顺序也是随机的。</p>
<p><code>WithValue()</code> 以及 <code>valueCtx</code> 的实现稍微与前两个有所不同，一方面 <code>valueCtx</code> 没有自己实现 <code>Done(), Deadline()</code> 等方法，所以其功能仅限于传值，另外，在 <code>WithValue()</code> 中并没有调用 <code>propagateCancel()</code>, 所以 <code>valueCtx</code> 并不会被放在父上下文的 <code>children</code> 中，他自己也没有 <code>children</code>, 所以使用 <code>valueCtx</code> 作为父上下文是没有意义的。</p>
<p>如非必要，一般无需使用 <code>WithValue()</code> 的功能传值，他一般用在传递请求对应用户的认证令牌或用于进行分布式追踪的请求 ID中。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Go/">Go</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/go/">go</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/520MianXiangDuiXiang520/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Junebao
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>